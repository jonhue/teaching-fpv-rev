\documentclass{beamer}
%
% Choose how your presentation looks.
%
% For more themes, color themes and font themes, see:
% http://deic.uab.es/~iblanes/beamer_gallery/index_by_theme.html
%
\mode<presentation>
{
  \usetheme{default}      % or try Darmstadt, Madrid, Warsaw, ...
  \usecolortheme{default} % or try albatross, beaver, crane, ...
  \usefonttheme{default}  % or try serif, structurebold, ...
  \setbeamertemplate{navigation symbols}{}
  \setbeamertemplate{caption}[numbered]
  \setbeamertemplate{footline}[frame number]
  \setbeamertemplate{itemize items}[circle]
}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{alltt}

\def\code#1{\texttt{\frenchspacing#1}}

\title[FPV revision course]{Functional Programming and Verification \\ revision course}
\author{Jonas Hübotter}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

% Uncomment these lines for an automatically generated outline.
\begin{frame}{Outline}
 \tableofcontents[subsectionstyle=hide, subsubsectionstyle=hide]
\end{frame}
\AtBeginSection[]
  {
     \begin{frame}
     \frametitle{Plan}
     \tableofcontents[currentsection, sectionstyle=show/hide, hideothersubsections]
     \end{frame}
  }

\section{Functional Programming and Haskell}

\subsection{Basic Haskell}

\begin{frame}{Basic Haskell}

\begin{tabular}{ll}
    function types & \code{f :: a -> b -> c}\pause \\
    function definitions & \code{f x y = \textit{...}}\pause \\
    function application & \code{f 1 2}\pause \\
    & \\
    conditional & \code{if True then a else b}\pause \\
    prefix/infix precedence & \code{f a `g` b} means \code{(f a) `g` b}\pause \\
    \code{\$} sign & \code{f \$ a `g` b} means \code{f (a `g` b)} \\
\end{tabular}

\end{frame}

\begin{frame}{Types}

\begin{tabular}{ll}
    \code{Bool} & \code{True} or \code{False}\pause \\
    \code{Int} & fixed-width integers\pause \\
    \code{Integer} & unbounded integers\pause \\
    \code{Char} & \code{'a'}\pause \\
    \code{String} & \code{"hello" :: [Char]}\pause \\
    \code{(a,b)} (Tuple) & \code{("hello",1) :: (String,Int)}
\end{tabular}

\end{frame}

\begin{frame}[fragile]{Tuples}

\begin{verbatim}
(1,"hello") :: (Int,String)
(x,y,z) :: (a,b,c)
-- ...
\end{verbatim}

Prelude functions: \code{fst}, \code{snd}

\end{frame}

\begin{frame}[fragile]{Lists}

Two ways of constructing a list:

\pause

\begin{alltt}
a = [1,2,3]          :: [Int]\pause
b = 1 : 2 : 3 : []   :: [Int]
\end{alltt}

\pause

Cons \code{(:)} and \code{[]} are \textcolor{blue}{constructors} of lists, that is a function that \textcolor{blue}{uniquely constructs} a value of the list type.

\pause

\vspace{1cm}
Intuitively: \code{(:) :: a -> [a] -> [a]}.

\end{frame}

\begin{frame}{Prelude functions}

\begin{tabular}{ll}
    \code{head :: [a] -> a} & first element\pause \\
    \code{last :: [a] -> a} & last element\pause \\
    \code{init :: [a] -> [a]} & every element but last \\
    & element\pause \\
    \code{tail :: [a] -> [a]} & every element but first \\
    & element\pause \\
    \code{elem :: a -> [a] -> Bool} & element in list?\pause \\
    \code{(++) :: [a] -> [a] -> [a]} & append lists\pause \\
    \code{reverse :: [a] -> [a]} & reverse list\pause \\
    \code{length :: [a] -> Int} & length of list\pause \\
    \code{null :: [a] -> Bool} & empty?\pause \\
    \code{concat :: [[a]] -> [a]} & flatten list\pause \\
    \code{zip :: [a] -> [b] -> [(a,b)]} & combine lists element-wise\pause \\
    \code{unzip :: [(a,b)] -> ([a],[b])} & separate list of tuples into \\
    & list of components \\
\end{tabular}

\end{frame}

\begin{frame}{Prelude functions (2)}

\begin{tabular}{ll}
    \code{replicate :: Int -> a -> [a]} & build list from repeated \\
    & element\pause \\
    \code{take :: Int -> [a] -> [a]} & prefix of list with given length\pause \\
    \code{drop :: Int -> [a] -> [a]} & list without prefix with given \\
    & length\pause \\
    \code{and ::[Bool] -> Bool} & conjunction over all elements\pause \\
    \code{or ::[Bool] -> Bool} & disjunction over all elements\pause \\
    \code{sum ::[Int] -> Int} & sum over all elements\pause \\
    \code{product ::[Int] -> Int} & product over all elements\pause \\
    \code{(!!) ::[a] -> Int -> a} & get element at index \\
\end{tabular}

\pause

\vspace{1cm}
search for functions by type signature on \url{https://hoogle.haskell.org/}.

\end{frame}

\begin{frame}[fragile]{Ranges}

\begin{alltt}
[1..5]\pause
= [1,2,3,4,5]

[1,3..10]\pause
= [1,3,5,7,9]

[1..]\pause
= \textit{[1,2,3...]}

[1,3..]\pause
= \textit{[1,3,5...]}
\end{alltt}

\end{frame}

\begin{frame}[fragile]{Local definitions}

\begin{alltt}
let x = \(e\sb1\) in \(e\sb2\)
\end{alltt}
defines \code{x} locally in $e_2$.

\pause

\vspace{1cm}
\begin{alltt}
\(e\sb2\) where x = \(e\sb1\)
\end{alltt}
also defines \code{x} locally in $e_2$ where $e_2$ has to be a function definition.

\end{frame}

\subsection{Recursion, guards, pattern matching}

\begin{frame}[fragile]{Recursion, guards, pattern matching}

\begin{block}{Guards}
\pause
\begin{exampleblock}{Example: maximum of two integers.}
\begin{alltt}
max2 :: Integer -> Integer -> Integer
max2 x y\pause
  | x >= y    = x
  | otherwise = y
\end{alltt}
\end{exampleblock}
\end{block}

\end{frame}

\begin{frame}[fragile]{Recursion}

\begin{block}{\centering Reduce problem into a solving a series of smaller problems \\ of a similar kind.}
\end{block}

\begin{exampleblock}{Example}
\begin{alltt}
factorial :: Integer -> Integer
factorial n\pause
  | n == 0 = 1                       -- base case
  | n > 0  = n * factorial (n – 1)   -- recursive case
\end{alltt}
\end{exampleblock}

\end{frame}

\begin{frame}[fragile]{Accumulating parameter}

Alternatively, \code{factorial} could be defined as

\begin{alltt}
factorial :: Integer -> Integer\pause
factorial n = aux n 1
  where
    aux :: Integer -> Integer -> Integer
    aux n acc\pause
      | n == 0 = acc
      | n > 0  = aux (n - 1) (n * acc)
\end{alltt}

\pause

The resulting function is \textcolor{blue}{tail recursive}, that is the recursive call is located at the very end of its body. \par
Therefore, no computation is done after the recursive function call returns.

\pause

\vspace{1cm}
In general, recursion using accumulating parameters is less readable.

\end{frame}

\begin{frame}[fragile]{Pattern matching}

A more compact syntax for recursion:

\begin{verbatim}
factorial 0 = 1
factorial n | n > 0 = n * factorial (n – 1)
\end{verbatim}

\pause

\begin{block}{\centering Patterns are expressions consisting only of constructors,  variables, and literals.}
\end{block}

\end{frame}

\begin{frame}[fragile]{Pattern matching}

\begin{exampleblock}{Examples}
\begin{alltt}
head :: [a] -> a\pause
head (x : _) = x

tail :: [a] -> [a]\pause
tail (_ : xs) = xs

null :: [a] -> Bool\pause
null []      = True
null (_ : _) = False
\end{alltt}
\end{exampleblock}

\end{frame}

\begin{frame}{Constructors vs Types}

What is the difference between \code{True} and \code{Bool}?

\begin{itemize}
    \item \code{True} is a \textcolor{blue}{constructor}, \code{Bool} is a \textcolor{blue}{type}.
    \item \code{True} can be used \textcolor{red}{in expressions} to build values of a type.
    \item \code{Bool} can be used \textcolor{red}{in type signatures} to hint at the type of bindings.
\end{itemize}

\pause

\vspace{1cm}
\begin{exampleblock}{Constructor?}
\begin{itemize}
    \item \makebox[2cm][l]{\code{False}}\pause \textcolor{green}{yes}
    \item \makebox[2cm][l]{\code{(:)}}\pause \textcolor{green}{yes}
    \item \makebox[2cm][l]{\code{Maybe}}\pause \textcolor{red}{no}
    \item \makebox[2cm][l]{\code{Just}}\pause \textcolor{green}{yes}
    \item \makebox[2cm][l]{\code{Nothing}}\pause \textcolor{green}{yes}
\end{itemize}
\end{exampleblock}

\end{frame}

\begin{frame}[fragile]{Case}

Pattern matching in nested expressions

\begin{verbatim}
singleOrEmpty :: [a] -> Bool
singleOrEmpty xs = case xs of []  -> True
                              [_] -> True
                              _   -> False
\end{verbatim}

\end{frame}

\subsection{List comprehensions}

\begin{frame}{List comprehensions}

\begin{block}{\centering \code{[ $expr$ | $E_1$, ..., $E_n$ ]}}
\end{block}

where $expr$ is an expression and each $E_i$ is a generator or a test.

\pause

\begin{itemize}
    \item a \textcolor{blue}{generator} is of the form \code{$pattern$ <- $list expression$}\pause
    \item a \textcolor{blue}{test} is a Boolean expression
\end{itemize}

\end{frame}

\begin{frame}[fragile]{List comprehensions}

\begin{exampleblock}{Examples}
\begin{alltt}
[x ^ 2 | x <- [1..5]]\pause
= [1, 4, 9, 16, 25]

[toLower c | c <- “Hello World!”]\pause
= “hello world!”

[(x, even x) | x <- [1..3]]\pause
= [(1, False), (2, True), (3, False)]
\end{alltt}
\end{exampleblock}

\end{frame}

\begin{frame}[fragile]{Multiple generators}

Generators are reduced from left to right. \par
A generator or test can depend on any generator to its left.

\pause

\begin{exampleblock}{Example}
\begin{alltt}
[(i,j) | i <- [1 .. 3], j <- [i .. 3]]\pause
= [(1,j) | j <- [1..3]] ++
  [(2,j) | j <- [2..3]] ++
  [(3,j) | j <- [3..3]]\pause
= [(1,1), (1,2), (1,3), (2,2), (2,3), (3,3)]
\end{alltt}
\end{exampleblock}

\end{frame}

\begin{frame}[fragile]{The meaning of list comprehensions}

\begin{alltt}
[e | x <- [a1,...,an]]\pause
= (let x = a1 in [e]) ++ · · · ++ (let x = an in [e])

[e | b]\pause
= if b then [e] else []

[e | x <- [a1,...,an], E]\pause
= (let x = a1 in [e | E]) ++ · · · ++
  (let x = an in [e | E])

[e | b, E]\pause
= if b then [e | E] else []
\end{alltt}

\end{frame}

\subsection{QuickCheck}

\begin{frame}[fragile]{QuickCheck}

QuickCheck tests check if a proposition holds true for a large number of random arguments. \par\pause
It can be used to \textit{test} the equivalence of two functions.

\pause

\begin{exampleblock}{Examples}
\begin{alltt}
import Test.QuickCheck

prop_max2 x y =\pause
  max2 x y == max x y

prop_max2_assoc x y z =\pause
  max2 x (max2 y z) == max2 (max2 x y) z

prop_factorial n =\pause
  n >= 0 ==> n < factorial n
\end{alltt}
\end{exampleblock}

\pause

Run \code{quickCheck prop\_max2} from GHCI to check the property.

\end{frame}

\subsection{Polymorphism}

\begin{frame}[fragile]{Polymorphism}

\begin{block}{\centering One function definition, having many types.}
\end{block}

\pause

\vspace{1cm}
\code{length :: [a] -> Int} is defined for all types \code{a} \\
where \code{a} is a \textcolor{blue}{type variable}.

\end{frame}

\begin{frame}{Subtype vs parametric polymorphism}

\begin{itemize}
    \item \textcolor{blue}{parametric polymorphism} \\ types may contain universally quantified type variables that are then replaced by actual types.
    \item \textcolor{blue}{subtype polymorphism} \\ any object of type \code{T'} where \code{T'} is a subtype of \code{T} can be used in place of objects of type \code{T}.
\end{itemize}

\pause

\vspace{1cm}
Haskell uses parametric polymorphism.

\end{frame}

\begin{frame}[fragile]{Type constraints}

Type variables can be constrained by \textcolor{blue}{type constraints}.

\begin{alltt}
(+) :: \textcolor{red}{Num a =>} a -> a -> a
\end{alltt}

Function \code{(+)} has type \code{a -> a -> a} for any type \code{a} of the \textcolor{blue}{type class} \code{Num}.

\pause

\vspace{1cm}
\begin{exampleblock}{Some type classes:}\pause
\begin{itemize}
    \item \code{Num}\pause
    \item \code{Integral}\pause
    \item \code{Fractional}\pause
    \item \code{Ord}\pause
    \item \code{Eq}\pause
    \item \code{Show}
\end{itemize}
\end{exampleblock}

\end{frame}

\begin{frame}[fragile]{Quiz}

\begin{alltt}
f x y z = if x then y else z\pause
f :: Bool -> a -> a -> a

f x y = [(x,y), (y,x)]\pause
f :: a -> a -> [(a,a)]

f x = [length u + v | (u,v) <- x ]\pause
f :: [([a],Int)] -> [Int]

f x y = [u ++ x | u <- y, length u < x ]\pause
\textcolor{red}{invalid}

f x y = [[(u,v) | u <- w, u, v <- x] | w <- y]\pause
f :: [a] -> [[Bool]] -> [[(Bool, a)]]
\end{alltt}

\end{frame}

\subsection{Currying, partial application, higher-order functions}

\begin{frame}{Currying}

A function is \textcolor{blue}{curried} when it takes its arguments one at a time, each time returning a new function.

\pause

\begin{exampleblock}{Example}
\vspace{0.25cm}
\begin{tabular}{ll}
    \code{f :: Int -> Int -> Int} & \code{f :: Int -> (Int -> Int)} \\
    \code{f x y = x + y} & \code{f x = \textbackslash y -> x + y}\pause \\
    & \\
    \code{f a b} & \code{(f a) b}\pause \\
    \code{= a + b}\pause & \code{= (\textbackslash y -> a + y) b}\pause \\
    & \code{= a + b}
\end{tabular}
\end{exampleblock}

\pause

\begin{block}{\centering Any function of two arguments can be viewed as \\ a function of the first argument that returns \\ a function of the second argument.}
\end{block}

\end{frame}

\begin{frame}[fragile]{Anonymous functions (lambdas)}

An \textcolor{blue}{anonymous function} (or \textcolor{blue}{lambda abstraction}) is a function without a name.

\pause

\begin{exampleblock}{Examples}
\begin{alltt}
({\textbackslash}x -> x + 1) 4\pause
= 5

({\textbackslash}x y -> x + y) 3 5\pause
= 8
\end{alltt}
\end{exampleblock}

\pause

What is the type of \code{\textbackslash n -> iter n succ} where \\
\code{iter :: Integer -> (a -> a) -> (a -> a)} \\
\code{succ :: Integer -> Integer}

\pause

\vspace{0.25cm}
\textcolor{red}{\code{Integer -> (Integer -> Integer)}}

\end{frame}

\begin{frame}{Partial application}

Every function of $n$ parameters can be applied to less than $n$ arguments.

\pause

A function is \textcolor{blue}{partially applied} when some arguments have already been applied to a function (some parameters are already \textit{fixed}), but some parameters are missing.

\pause

\vspace{1cm}
\begin{exampleblock}{Partially applied?}
\begin{itemize}
    \item \makebox[5cm][l]{\code{elem 5}}\pause \textcolor{green}{yes}
    \item \makebox[5cm][l]{\code{(`elem` [1..5]) 0}}\pause \textcolor{red}{no}
\end{itemize}
\end{exampleblock}

\pause

\vspace{0.25cm}
Expressions of the form \code{($infixop$ $expr$)} or \code{($expr$ $infixop$)} are called \textcolor{blue}{sections}.

\end{frame}

\begin{frame}[fragile]{Higher-order functions}

A \textcolor{blue}{higher-order function} is a function that takes another function as an argument or returns a function.

\pause

\begin{exampleblock}{Examples}
\begin{itemize}
    \item \code{(.) :: (b -> c) -> (a -> b) -> (a -> c)}\pause
    \item \code{const :: a -> (b -> a)}\pause
    \item \code{curry :: ((a,b) -> c) -> (a -> b -> c)}\pause
    \item \code{uncurry :: (a -> b -> c) -> ((a,b) -> c)}\pause
    \item \code{filter :: (a -> Bool) -> [a] -> [a]}\pause
    \item \code{map :: (a -> b) -> [a] -> [b]}\pause
    \item \code{all, any :: (a -> Bool) -> [a] -> Bool}\pause
    \item \code{takeWhile, dropWhile :: (a -> Bool) -> [a] -> [a]}
\end{itemize}
\end{exampleblock}

\end{frame}

\begin{frame}[fragile]{Fold}

\begin{block}{\centering Folding is the most elementary way \\ of combining elements of a list.}
\end{block}

Right-associative (\code{foldr}):

\begin{verbatim}
foldr :: (b -> a -> a) -> a -> [b] -> a
foldr f a []     = a
foldr f a (x:xs) = f x (foldr f a xs)
\end{verbatim}

\pause

Why is this right-associative?

\pause

\begin{alltt}
foldr (+) 0 [1,2,3]\pause
= 1 + foldr (+) 0 [2,3]\pause
= 1 + (2 + foldr (+) 0 [3])\pause
= 1 + (2 + (3 + foldr (+) 0 []))\pause
= 1 + (2 + (3 + 0))\pause
= 1 + (2 + 3)\pause
= 1 + 5 = 6
\end{alltt}

\end{frame}

\section{Types}

\subsection{Type aliases}

\begin{frame}[fragile]{Type aliases}

Allows the renaming of a more complex type expression.

\pause

\begin{exampleblock}{Examples}
\begin{verbatim}
type String = [Char]
type List a = [a]
\end{verbatim}
\end{exampleblock}

\end{frame}

\subsection{Type Classes}

\begin{frame}{Type Classes}

\begin{block}{\centering Type classes are collections of types that implement some fixed set of functions.}
\end{block}

\pause

Similar concepts are commonly called \textit{interfaces}.

\pause

\vspace{1cm}
Creating and using a type class:\pause
\begin{enumerate}
    \item creating a type class $\sim$ creating an interface (define set of functions)\pause
    \item instantiating a type class $\sim$ implementing an interface (implement a set of functions for a member of a type class)
\end{enumerate}

\end{frame}

\begin{frame}[fragile]{Type Classes}

\begin{exampleblock}{Examples}
\begin{alltt}
class Eq a where\pause
  (==) :: a -> a -> Bool\pause

instance Eq Bool where\pause
  True  == True  = True\pause
  False == False = True\pause
  _     == _     = False
\end{alltt}
\end{exampleblock}

\end{frame}

\begin{frame}[fragile]{Constrained instances}

Instances of type classes can be constrained.

\pause

\begin{exampleblock}{Example}
\begin{alltt}
instance (Eq a) => Eq [a] where\pause
  [] == [] = True\pause
  (x:xs) == (y:ys) = x == y && xs == ys\pause
  _ == _ = False
\end{alltt}
\end{exampleblock}

\end{frame}

\begin{frame}[fragile]{Subclasses}

\begin{exampleblock}{Example}
\begin{verbatim}
class (Eq a) => Ord a where
  (<=), (<), (>=), (>) :: a -> a -> Bool
\end{verbatim}

Class \code{Ord} inherits all functions of class \code{Eq}.
\end{exampleblock}

\pause

\vspace{1cm}
Before instantiating a subclass with a type, the type must be an instance of all \textit{"superclasses"}.

\pause

\begin{alltt}
instance Ord Bool where
  b1 <= b2 = not b1 || b2
  b1 < b2 = b1 <= b2 && not(b1 == b2)
\end{alltt}

\end{frame}

\subsection{Algebraic Data Types}

\begin{frame}{Algebraic Data Types}

A custom datatype with one or more constructors.

\pause

\begin{block}{\centering \code{data $type$ $a_1 \dots a_n$ = $constructor$ $a_k \dots a_l$ | ...}}
\end{block}

\pause

\vspace{1cm}
Constructors are
\begin{itemize}
    \item a \textit{prefix operator} starting with a capital letter; or
    \item an \textit{infix operator} starting with \code{:}.
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Algebraic Data Types}

\begin{exampleblock}{Examples}
\begin{alltt}
data Bool = False | True\pause

data Maybe a = Nothing | Just a
  deriving (Eq, Show)\pause

data Nat = Zero | Suc Nat
  deriving (Eq, Show)\pause

data [a] = [] | (:) a [a]
  deriving Eq\pause

data Tree a = Empty | Node a (Tree a) (Tree a)
  deriving (Eq, Show)
\end{alltt}
\end{exampleblock}

\end{frame}

\begin{frame}{Algebraic Data Types}

Terminology:\pause
\begin{itemize}
    \item a \textcolor{blue}{$n$-ary constructor} is a function that unambiguously constructs values of a type encapsulating $n$ arguments.\pause
    \item nullary constructors are also called \textcolor{blue}{constants}.\pause
    \item a type that expects a \textit{type argument} is called a \textit{parametrized type}.\pause
    \item \textcolor{blue}{data constructors} are used at the \textit{term level}, \textcolor{blue}{type constructors} are used at the \textit{type level}.
\end{itemize}

\end{frame}

\begin{frame}{Algebraic Data Types}

A datatype can be thought of as the set of possible values of that type.

\pause

\begin{itemize}
    \item the \textcolor{blue}{cardinality} of a datatype is the number of all its possible values.\pause
    \item a \textcolor{blue}{sum type} is a type with more than one constructor (similar to a logical $\lor$).\pause
    \item a \textcolor{blue}{product type} is a type whose data constructor takes more than one argument (similar to a logical $\land$).
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Pattern matching}

Pattern matching works just the same for custom constructors as for predefined constructors.

\pause

\begin{exampleblock}{Examples}
\begin{alltt}
find :: Ord a => a -> Tree a -> Bool\pause
find _ Empty = False\pause
find x (Node a l r)\pause
  | x < a     = find x l\pause
  | a < x     = find x r\pause
  | otherwise = True

insert :: Ord => a -> Tree a -> Tree a\pause
insert x Empty = Node x Empty Empty\pause
insert x (Node a l r)\pause
  | x < a     = Node a (insert x l) r\pause
  | a < x     = Node a l (insert x r)\pause
  | otherwise = Node a l r
\end{alltt}
\end{exampleblock}

\end{frame}

\subsection{Modules, Abstract Data Types}

\begin{frame}{Modules}

Collection of type, function, class and other definitions.

\pause

\begin{exampleblock}{Examples}
\code{module M where} \par
exports everything defined in \code{M}\pause

\vspace{0.25cm}
\code{module M (T, f, ...) where} \par
exports only \code{T, f, ...}
\end{exampleblock}

\end{frame}

\begin{frame}[fragile]{Exporting data types}

\code{module M (T) where} \par
\code{data T = ...} \par
\textcolor{blue}{exports only \code{T} but not its constructors}\pause

\vspace{0.25cm}
\code{module M (T(C,D,...)) where} \par
\code{data T = ...} \par
\textcolor{blue}{exports \code{T} and its constructors \code{C, D, ...}}\pause

\vspace{0.25cm}
\code{module M (T(..)) where} \par
\code{data T = ...} \par
\textcolor{blue}{exports \code{T} and all its constructors}\pause

\vspace{0.25cm}
Not allowed (why?): \par
\textcolor{red}{\code{module M (T,C,D) where}}

\pause

Constructors could have the same name as a type.

\end{frame}

\begin{frame}{Abstract Data Types}

\begin{block}{\centering Hides data representation by wrapping data in a constructor that is not exported.}
\end{block}

\end{frame}

\begin{frame}[fragile]{Abstract Data Types}

\begin{exampleblock}{Example}
\begin{alltt}
module Set (Set, empty, insert, isin, size) where
-- Interface
empty :: Set a
insert :: Eq a => a -> Set a -> Set a
isin :: Eq a => a -> Set a -> Bool
size :: Set a -> Int\pause
-- Implementation
\textcolor{blue}{newtype Set a = Set [a]}\pause

empty = Set []\pause
insert x (Set xs) = Set (if elem x xs then xs else x:xs)\pause
isin x (Set xs) = elem x xs\pause
size (Set xs) = length xs
\end{alltt}
\end{exampleblock}

\end{frame}

\begin{frame}{\code{type} vs \code{data} vs \code{newtype}}

\begin{itemize}
    \item \code{type} is used to create type aliases\pause
    \item \code{data} is used to create algebraic data types (types witha custom shape)\pause
    \item \code{newtype} is used to create a custom constructor for a single type without adding any runtime overhead
\end{itemize}

\end{frame}

\subsection{Type inference}

\begin{frame}{Type inference}

\begin{block}{\centering Inferring/reconstructing the type of an expression.}
\end{block}

\pause

Given an expression $e$.\pause
\begin{enumerate}
    \item give all variables in $e$ distinct type variables\pause
    \item give each function $f :: T$ in $e$ a new general type with fresh type variables\pause
    \item for each sub-expression in $e$ set up an equation linking the type of parameters and arguments\pause
    \item simplify the set of equations by replacing equivalences
\end{enumerate}

\end{frame}

\begin{frame}{Type inference}

\begin{exampleblock}{Example}
Given \code{f u v = min (head u) (last (concat v))}

\pause

\vspace{0.25cm}
Step 1\pause
\begin{enumerate}
    \item \code{u :: a}
    \item \code{v :: b}
\end{enumerate}
Step 2\pause
\begin{enumerate}
    \item \code{head :: [c] -> c}\pause
    \item \code{concat :: [[d]] -> [d]}\pause
    \item \code{last :: [e] -> e}\pause
    \item \code{min :: Ord f => f -> f -> f}
\end{enumerate}
\end{exampleblock}

\end{frame}

\begin{frame}{Type inference}

\begin{exampleblock}{Example (cont.)}
Given \code{f u v = min (head u) (last (concat v))}

\vspace{0.25cm}
Step 3\pause
\begin{enumerate}
    \item from \code{head u} derive \code{[c] = a}\pause
    \item from \code{concat v} derive \code{[[d]] = b}\pause
    \item from \code{last (concat v)} derive \code{[e] = [d]}\pause
    \item from \code{min (head u) (last (concat v))} derive \code{f = c} and \code{f = e}
\end{enumerate}
\end{exampleblock}

\end{frame}

\begin{frame}{Type inference}

\begin{exampleblock}{Example (cont.)}
Given \code{f u v = min (head u) (last (concat v))} \par
Goal \code{f :: Ord f => a -> b -> f}

\vspace{0.25cm}
Step 4\pause
\begin{enumerate}
    \item apply \code{[c] = a} and update\pause
        \begin{itemize}
            \item \code{u :: [c]}\pause
        \end{itemize}
    \item apply \code{[[d]] = b} and update\pause
        \begin{itemize}
            \item \code{v :: [[d]]}\pause
        \end{itemize}
    \item apply \code{[e] = [d]} to get \code{e = d} and update\pause
        \begin{itemize}
            \item \code{v :: [[e]]}\pause
            \item \code{concat :: [[e]] -> [e]}\pause
        \end{itemize}
    \item apply \code{f = c} and update\pause
        \begin{itemize}
            \item \code{u :: [f]}\pause
            \item \code{head :: [f] -> f}
        \end{itemize}
\end{enumerate}
\end{exampleblock}

\end{frame}

\begin{frame}{Type inference}

\begin{exampleblock}{Example (cont.)}
Given \code{f u v = min (head u) (last (concat v))} \par
Goal \code{f :: Ord f => a -> b -> f}

\vspace{0.25cm}
Step 4 (cont.)\pause
\begin{enumerate}
    \item apply \code{f = e} and update\pause
        \begin{itemize}
            \item \code{v :: [[f]]}\pause
            \item \code{concat :: [[f]] -> [f]}\pause
            \item \code{last :: [[f]] -> [f]}\pause
        \end{itemize}
    \item no further simplification possible, \\ return \textcolor{blue}{\code{f :: Ord f => [f] -> [[f]] -> f}}
\end{enumerate}
\end{exampleblock}

\end{frame}

\section{Proofs}

\subsection{Structural induction}

\begin{frame}{Structural induction}

\begin{block}{\centering Induction on the structural definition of a datatype}
\end{block}

\pause

To prove property \textcolor{blue}{\code{P(x)}} for all finite values \code{x} of type $T$, \par
prove \textcolor{blue}{\code{P(C)}} for each constructor $C$ of $T$.

\pause

\vspace{0.5cm}
\begin{itemize}
    \item \textcolor{blue}{base cases} are represented by proofs for non-recursive constructors\pause
    \item \textcolor{blue}{inductive cases} are represented by proofs for recursive constructors
\end{itemize}

\pause

\vspace{0.5cm}
\textcolor{red}{Each recursive type parameter has a separate induction hypothesis. (Why?)}

\end{frame}

\begin{frame}[fragile]{Structural induction on trees}

\begin{exampleblock}{Example}
\begin{alltt}
data Tree a = Leaf | Node (Tree a) a (Tree a)\pause

mirror Leaf = Leaf
mirror (Node l v r) = Node (mirror r) v (mirror l)

id x = x

(f . g) x = f (g x)
\end{alltt}

\pause

Prove \textcolor{blue}{\code{(mirror . mirror) t .=. id t}}.
\end{exampleblock}

\end{frame}

\begin{frame}[fragile]{Structural induction on trees}

\begin{exampleblock}{Example (cont.)}
\small\begin{alltt}
\textcolor{blue}{Lemma: (mirror . mirror) t .=. id t}\pause
Proof by induction on Tree t\pause
\textcolor{blue}{Case Leaf}\pause
  To show: (mirror . mirror) Leaf .=. id Leaf
  Proof
                        (mirror . mirror) Leaf\pause
    (by def .)      .=. \underline{mirror (mirror Leaf)}\pause
    (by def mirror) .=. \underline{mirror Leaf}\pause
    (by def mirror) .=. \underline{Leaf}\pause
    (by def id)     .=. \underline{id Leaf}
  QED
\end{alltt}\normalsize
\end{exampleblock}

\end{frame}

\begin{frame}[fragile]{Structural induction on trees}

\begin{exampleblock}{Example (cont.)}
\small\begin{alltt}
\textcolor{blue}{Case Node l v r}\pause
  To show: (mirror . mirror) (Node l v r)
           .=. id (Node l v r)\pause
  \textcolor{blue}{IH1}:     (mirror . mirror) l .=. id l
  \textcolor{blue}{IH2}:     (mirror . mirror) r .=. id r
  Proof
                        (mirror . mirror) (Node l v r)\pause
    (by def .)      .=. \underline{mirror (mirror (Node l v r))}\pause
    (by def mirror)
    .=. mirror (\underline{Node (mirror r) v (mirror l)})\pause
    (by def mirror)
    .=. \underline{Node (mirror (mirror l)) v (mirror (mirror r))}\pause
    (by def .)
    .=. Node (\underline{{(mirror . mirror) l}}) v (mirror (mirror r))\pause
    (by def .)
    .=. Node ((mirror . mirror) l) v (\underline{(mirror . mirror) r})
\end{alltt}\normalsize
\end{exampleblock}

\end{frame}

\begin{frame}[fragile]{Structural induction on trees}

\begin{exampleblock}{Example (cont.)}
\small\begin{alltt}
  To show: (mirror . mirror) (Node l v r)
           .=. id (Node l v r)
  \textcolor{blue}{IH1}:     (mirror . mirror) l .=. id l
  \textcolor{blue}{IH2}:     (mirror . mirror) r .=. id r
  Proof
    \vdots
    (by def .)
    .=. Node ((mirror . mirror) l) v ((mirror . mirror) r)\pause
    (by IH1)    .=. Node \underline{(id l)} v ((mirror . mirror) r)
    (by IH2)    .=. Node (id l) v \underline{(id r)}\pause
    (by def id) .=. Node \underline{l} v (id r)\pause
    (by def id) .=. Node l v \underline{r}\pause
    (by def id) .=. \underline{id (Node l v r)}
  QED
QED
\end{alltt}\normalsize
\end{exampleblock}

\end{frame}

\begin{frame}{Structural induction on lists}

Definition of a list:\pause
\begin{alltt}
data [a] = [] | a : [a]
\end{alltt}

\pause

To prove property \textcolor{blue}{\code{P(xs)}} for all finite lists \code{xs} \par
\begin{itemize}
    \item \textcolor{blue}{Base case:} Prove \textcolor{blue}{\code{P([])}} \par
    \item \textcolor{blue}{Inductive case:} Prove \textcolor{blue}{\code{P(xs)} $\implies$ \code{P(x:xs)}}
\end{itemize}

\pause

\vspace{1cm}
\begin{block}{\centering Structural induction on lists \\ are inductions on the length of a list}
\end{block}

\end{frame}

\subsection{Case analysis}

\begin{frame}[fragile]{Case analysis}

For conditionals consider separate proofs for the cases \code{True} and \code{False}.

\pause

\begin{exampleblock}{Example}
\small\begin{alltt}
To show: if x < y then \(A\) else \(B\) .=. f x y\pause
\textcolor{blue}{Proof by case analysis on Bool x < y}
\textcolor{blue}{Case True}
  Assumption: x < y .=. True
  Proof
                        if x < y then \(A\) else \(B\)\pause
    (by Assumption) .=. if True then \(A\) else \(B\)\pause
    (by ifTrue)     .=. \(A\)
    ...
  QED\pause
\textcolor{blue}{Case False}
  ...
QED
\end{alltt}\normalsize
\end{exampleblock}

\end{frame}

\subsection{Generalization}

\begin{frame}{Generalization}

\begin{center}
    \textcolor{blue}{When using the IH, variables may be replaced by arbitrary expressions, only} \textcolor{red}{the induction variable must stay fixed}.
\end{center}

\pause

\vspace{0.5cm}
\begin{exampleblock}{Example}
Consider a structural induction on \code{xs} \\
with the IH \code{f xs ys .=. g xs ys}. \par\pause
Then,

\begin{center}
    \code{f xs ys .=. g xs ys} $\implies$ \code{f xs [] .=. g xs []}.
\end{center}
\end{exampleblock}

\end{frame}

\subsection{Extensionality}

\begin{frame}[fragile]{Extensionality}

\begin{center}
    \textcolor{blue}{Two functions are equal \\ if for all arguments they yield the same result}.
\end{center}

\pause

\vspace{0.5cm}
\begin{exampleblock}{Example}
\begin{alltt}
Lemma: f .=. g
\textcolor{blue}{Proof by extensionality with xs}
  To show: f xs .=. g xs
  Proof by induction on List xs
    ...
  QED
QED
\end{alltt}
\end{exampleblock}

\end{frame}

\subsection{Computation induction}

\begin{frame}{Computation induction}

To prove property \textcolor{blue}{\code{P($x_1, \dots, x_k$)}} for all $x_1$, \dots, $x_k$, \par
for every defining equation

\begin{center}
\textcolor{blue}{\code{f $p_1, \dots, p_k$ = ... f $e_{11}, \dots, e_{1k}$ ... f $e_{n1}, \dots, e_{nk}$ ...}}
\end{center}

prove \textcolor{blue}{\code{P($e_{11}, \dots, e_{1k}$)}, \dots, \code{P($e_{n1}, \dots, e_{nk}$)} $\implies$ \code{P($p_1, \dots, p_k$)}}.

\pause

\vspace{1cm}
\begin{block}{\centering Induction on the length of a computation}
\end{block}

\pause

Also referred to as an \textcolor{blue}{induction on the computation} of a function \code{f} or \textcolor{blue}{\code{f}-induction}.

\end{frame}

\begin{frame}[fragile]{Computation induction}

\begin{exampleblock}{Example}
\begin{alltt}
splice [] ys = ys
spice (x:xs) ys = x : splice ys xs
\end{alltt}

\pause

\code{splice}-induction: To prove \code{P(xs, ys)} for all \code{xs} and \code{ys}, prove\pause
\begin{enumerate}
    \item \code{P([], ys)}\pause
    \item \code{P(ys, xs)} $\implies$ \code{P(x:xs, ys)}
\end{enumerate}

\pause

\vspace{0.5cm}
Prove \textcolor{blue}{\code{length (splice xs ys) .=. length xs + length ys}}.

\pause

\vspace{0.25cm}
\textcolor{red}{Structural induction does not work (why?)}
\end{exampleblock}

\end{frame}

\begin{frame}[fragile]{Computation induction}

\begin{exampleblock}{Example (cont.)}
\small\begin{alltt}
\textcolor{blue}{Lemma: length (splice xs ys) .=. length xs + length ys}\pause
Proof by splice-induction on xs and ys\pause
\textcolor{blue}{Case 1}\pause
  To show: length (splice [] ys) .=. length [] + length ys
  Proof
                        length (splice [] ys)\pause
    (by def splice) .=. length \underline{ys}

                        length [] + length ys\pause
    (by def length) .=. \underline{0} + length ys\pause
    (by def 0)      .=. \underline{length ys}
  QED
\end{alltt}\normalsize
\end{exampleblock}

\end{frame}

\begin{frame}[fragile]{Computation induction}

\begin{exampleblock}{Example (cont.)}
\small\begin{alltt}
\textcolor{blue}{Case 2}\pause
  To show: length (splice (x:xs) ys)
           .=. length (x:xs) + length ys\pause
  IH:      length (splice ys xs)
           .=. length ys + length xs
  Proof
                        length (splice (x:xs) ys)\pause
    (by def splice) .=. length \underline{(x : splice ys xs)}\pause
    (by def length) .=. \underline{1 + length (splice ys xs)}\pause
    (by IH)         .=. 1 + \underline{(length ys + length xs)}\pause
    (by comm_sum)   .=. 1 + \underline{(length xs + length ys)}\pause
    (by assoc_sum)  .=. \underline{(1 + length xs) + length ys}\pause
    (by def length) .=. \underline{length (x:xs)} + length ys
  QED
QED
\end{alltt}\normalsize
\end{exampleblock}

\end{frame}

\begin{frame}{Structural vs computation induction}

\begin{itemize}
    \item \textcolor{blue}{structural induction} \\ inductive proof over the structural definition of a datatype.
    \item \textcolor{blue}{computation induction} \\ inductive proof over the structural definition of a function.
\end{itemize}

\end{frame}

\section{Correctness}

\begin{frame}{Correctness}

\begin{block}{\centering How can we prove that two modules implement the same structure?}
\end{block}\pause
\begin{block}{\centering $\iff$}
\end{block}
\begin{block}{\centering How can we prove that the implementation of one module simulates its counterpart?}
\end{block}

\end{frame}

\begin{frame}[fragile]{Lists and sets}

Each list \code{[$x_1$, ..., $x_n$]} represents the set $\{x_1, \dots, x_n\}$.

\pause

In mathematical terms:
\begin{alltt}
\(\alpha\) :: [a] -> \(\{a\}\)
\(\alpha\) [\(x_1\), ..., \(x_n\)]  = \(\{x_1, \dots, x_n\}\)
\end{alltt}

$\alpha$ is an \textcolor{blue}{abstraction function}.

\pause

\vspace{1cm}
Lists simulate sets $\implies$ \textcolor{red}{$\alpha$ must be a homomorphism}.

\end{frame}

\begin{frame}[fragile]{Lists and sets}

\begin{alltt}
empty = []
insert x xs = if elem x xs then xs else x:xs
isin x xs = elem x xs
size xs = length xs\pause

invar :: [a] -> Bool\pause
invar []     = True\pause
invar (x:xs) = not (elem x xs) && invar xs
\end{alltt}

Simulation requirements: \par\pause
\textcolor{blue}{\code{$\alpha$ empty = $\{\}$}} \par\pause
\textcolor{blue}{\code{invar xs $\implies$ $\alpha$ (insert x xs) = $\{$x$\}$ $\cup$ $\alpha$ xs}} \par\pause
\textcolor{blue}{\code{invar xs $\implies$ isin x xs = x $\in$ $\alpha$ xs}} \par\pause
\textcolor{blue}{\code{invar xs $\implies$ size xs = $\lvert \alpha$ xs$\rvert$}}

\pause

\begin{alertblock}{\centering \code{invar} must be preserved by every operation.}
\end{alertblock}

\end{frame}

\begin{frame}{Correctness proof strategy}

Let $C$ and $A$ be two modules that have the same interface: a type $T$ and a set of functions $F$.

\pause

To prove that $C$ is a correct implementation of $A$ define
\begin{enumerate}
    \item an \textcolor{blue}{abstraction function} \code{$\alpha$ :: $C.T$ -> $A.T$}
    \item and an \textcolor{blue}{invariant} \code{invar :: $C.T$ -> Bool}
\end{enumerate}
and prove for each $f \in F$:\pause
\begin{itemize}
    \item \code{invar} is invariant \\
        \textcolor{blue}{\code{invar $x_1$ $\land \dots \land$ invar $x_n$ $\implies$ invar ($C.f$ $x_1$ $\dots$ $x_n$)}}\pause
    \item $C.f$ simulates $A.f$ \\
        \textcolor{blue}{\code{invar $x_1$ $\land \dots \land$ invar $x_n$ $\implies$}} \\
        \textcolor{blue}{\code{$\alpha$ ($C.f$ $x_1$ $\dots$ $x_n$) = $A.f$ ($\alpha$ $x_1$) $\dots$ ($\alpha$ $x_n$)}}
\end{itemize}

\end{frame}

\section{I/O}

\begin{frame}{I/O}

\begin{block}{Side effects}
Up until now we only considered programs that do not have side effects.

\pause

To reason about programs like in mathematics, the programming language must have \textcolor{blue}{referential transparency}. That is, any expression can be replaced by its value without changing the meaning of the program.

\pause

Programming languages that have referential transparency are called \textcolor{blue}{pure}.
\end{block}

\end{frame}

\subsection{I/O in Haskell}

\begin{frame}{I/O in Haskell}

Haskell distinguishes expressions without side effects (\textcolor{blue}{pure expressions}) from expressions with side effects (\textcolor{blue}{actions}) by their type:

\begin{block}{\centering \code{IO a}}
\end{block}

is the type of (I/O) actions that return a value of type \code{a}.

\pause

\begin{exampleblock}{Examples}
\begin{itemize}
    \item \code{Char}: the type of pure expressions returning a \code{Char}\pause
    \item \code{IO Char}: the type of actions returning a \code{Char}\pause
    \item \code{IO ()}: the type of actions returning nothing
\end{itemize}
\end{exampleblock}

\pause

\begin{alertblock}{\centering \code{()} is the type of empty tuples with the only value \code{()}.}
\end{alertblock}

\end{frame}

\begin{frame}{Basic actions}

\begin{itemize}
    \item \textcolor{blue}{\code{getChar :: IO Char}} \\
        Reads a \code{Char} from standard input, \\
        echoes it to standard output, \\
        and returns it as the result\pause
    \item \textcolor{blue}{\code{putChar :: Char -> IO ()}} \\
        Writes a \code{Char} to standard output, \\
        and returns no result\pause
    \item \textcolor{blue}{\code{return :: a -> IO a}} \\
        Performs no action, \\
        just returns the given value as a result
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Read/Show}

\begin{itemize}
    \item \code{Read}: parsing \code{String}
\begin{alltt}
\textcolor{blue}{class Read a where}
  \textcolor{blue}{read :: String -> a}
\end{alltt}\pause
    \item \code{Show}: converting to \code{String}
\begin{alltt}
\textcolor{blue}{class Show a where}
  \textcolor{blue}{show :: a -> String}
\end{alltt}
\end{itemize}

\end{frame}

\begin{frame}{Important actions}

\begin{itemize}
    \item \textcolor{blue}{\code{putStr :: String -> IO ()}} \\
        Prints a string to standard output\pause
    \item \textcolor{blue}{\code{putStrLn :: String -> IO ()}} \\
        Prints a string followed by a newline to standard output\pause
    \item \textcolor{blue}{\code{getLine :: IO String}} \\
        Reads everything up until a newline from standard input
\end{itemize}

\end{frame}

\subsection{Sequencing}

\begin{frame}[fragile]{Sequencing}

A sequence of actions can be combined into a single action with the keyword \textcolor{blue}{\code{do}}.

\pause

\begin{exampleblock}{Example}
\begin{verbatim}
get2 :: IO (Char,Char)
get2 = do x <- getChar   -- result is named x
          getChar        -- result is ignored
          y <- getChar
          return (x,y)
\end{verbatim}
\end{exampleblock}

\end{frame}

\begin{frame}[fragile]{Sequencing}

General format:
\begin{alltt}
do \(a\sb1\)
   \vdots
   \(a\sb{n}\)
\end{alltt}

\pause

where each $a_i$ can be one of
\begin{itemize}
    \item an action \\
        Effect: execute action
    \item \code{$x$ <- $action$} \\
        Effect: execute \code{$action$ :: IO a}, give result the name \code{x :: a}
    \item \code{let x = $expr$} \\
        Effect: give \code{$expr$} the name \code{x}
\end{itemize}

\end{frame}

\subsection{Interlude: Monads}

\begin{frame}[fragile]{Interlude: Monads}

\begin{block}{\centering Monads are a general approach to computations \\ that incur side effects.}
\end{block}

\pause

Idea: pipe data through the program implicitly.

\pause

In Haskell:
\begin{alltt}
class Monad m where\pause
  (>>=) :: m a -> (a -> m b) -> m b\pause
  return :: a -> m a
\end{alltt}

\pause

\vspace{0.25cm}
\begin{alltt}
\textcolor{blue}{do x <- act1}
   \textcolor{blue}{act2}
\end{alltt}

is syntactic sugar for

\begin{alltt}
\textcolor{blue}{act1 >>= ({\textbackslash}x -> act2)}
\end{alltt}

\end{frame}

\begin{frame}[fragile]{Interlude: Monads}

\begin{exampleblock}{Example: \code{Maybe} as a monad}
\begin{alltt}
\textcolor{blue}{instance Monad Maybe where}
  \textcolor{blue}{m >>= f = case m of}
              \textcolor{blue}{Nothing -> Nothing}
              \textcolor{blue}{Just x  -> f x}
  \textcolor{blue}{return v = Just v}
\end{alltt}

\pause

Using \code{do}, failure propagation and unwrapping of \code{Just} happens automatically.

\pause

\begin{alltt}
x :: Maybe Int
y :: Maybe Int
sum2 :: Maybe Int\pause
sum2 = do
  a <- someMaybeInt
  b <- anotherMaybeInt
  return (a + b)
\end{alltt}

\end{exampleblock}

\end{frame}

\section{Evaluation}

\begin{frame}[fragile]{Evaluation}

Expressions are evaluated (\textcolor{blue}{reduced}) by successively applying definitions until no further reduction is possible.

\pause

\vspace{1cm}
An expression may have many reducible sub-expressions:

\begin{alltt}
\centering \underline{sq \underline{(3+4)}}
\end{alltt}

A reducible expression is also called \textcolor{blue}{redex}.

\end{frame}

\begin{frame}{Reduction strategies}

\begin{block}{Innermost}
Reduces innermost redex first. \par\pause
$\implies$ arguments are evaluated before they are substituted into the function body. \par\pause
$\implies$ corresponds to \textcolor{blue}{call by value}
\end{block}

\pause

\begin{block}{Outermost}
Reduces outermost redex first. \par\pause
$\implies$ unevaluated arguments are substituted into the function body. \par\pause
$\implies$ corresponds to \textcolor{blue}{call by name}
\end{block}

\pause

\begin{block}{Lazy}
Combines an outermost reduction strategy with the \textcolor{blue}{sharing} of expressions. \par\pause
$\implies$ unevaluated arguments are substituted into the function body, but are only evaluated once for all copies of the same expression. \par\pause
$\implies$ \textit{\textcolor{blue}{call by need}}
\end{block}

\end{frame}

\begin{frame}{Theorems}

\begin{itemize}
    \item Any two terminating evaluations of the same Haskell expression lead to the same final result.\pause
    \item If expression $e$ has a terminating reduction sequence, then outermost reduction of $e$ also terminates. \\ \pause
        $\implies$ outermost reduction terminates as often as possible\pause
    \item Lazy evaluation never needs more steps than innermost reduction.
\end{itemize}

\end{frame}

\begin{frame}{Principles of lazy evaluation}

\begin{itemize}
    \item Arguments of functions are evaluated only if needed to continue the evaluation of the function.
    \item Arguments are not necessarily evaluated fully, but only far enough to evaluate the function.
    \item Each argument is evaluated at most once. (sharing!)
\end{itemize}

\pause

\vspace{1cm}
\begin{alertblock}{\centering Haskell never reduces inside a lambda}
\end{alertblock}

Why?\pause
\begin{itemize}
    \item lazy evaluation uses as few steps as possible
    \item functions can only be applied
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Infinite lists}

\begin{exampleblock}{Example: \code{head ones}}
\begin{alltt}
ones :: [Int]
ones = 1 : ones
\end{alltt}

\code{ones} defines an infinite list of $1$s. \code{ones} is called a \textcolor{blue}{producer}.

\pause

\vspace{0.5cm}
Outermost reduction: \par
\textcolor{blue}{\code{head ones}} \par\pause
\textcolor{blue}{\code{= head (1 : ones)}} \par\pause
\textcolor{blue}{\code{= 1}}

\vspace{0.5cm}
Innermost reduction: \par
\textcolor{red}{\code{head ones}} \par\pause
\textcolor{red}{\code{= head (1 : ones)}} \par\pause
\textcolor{red}{\code{= head (1 : 1 : ones)}} \par
\textcolor{red}{\code{= ...}}
\end{exampleblock}

\end{frame}

\begin{frame}{Infinite lists}

\begin{block}{\centering Haskell lists are never actually infinite \\ but only potentially infinite}
\end{block}

\begin{block}{\centering Lazy evaluation computes as much of the infinite list as needed}
\end{block}

\end{frame}

\section{Time complexity analysis}

\begin{frame}{Time complexity analysis}

Assumption: \textcolor{blue}{One reduction step takes one time unit}

\pause

\vspace{0.5cm}
\textcolor{blue}{$T_f(n) = $} number of steps for the evaluation of $f$ when applied to an argument of size $n$ in the worst case

\pause

\vspace{0.5cm}
Size is a specific measure based on the argument type of $f$.

\pause

\vspace{0.5cm}
Calculating $T_f(n)$:
\begin{enumerate}
    \item from the equations for $f$ derive equations for $T_f$
    \item if the equations for $T_f$ are recursive, solve them
\end{enumerate}

\end{frame}

\begin{frame}[fragile]{Time complexity analysis}

\begin{exampleblock}{Example}
\begin{alltt}
[] ++ ys = ys
(x:xs) ++ ys = x : (xs ++ ys)
\end{alltt}

\pause

$T_{\code{++}}(0, n) = O(1)$ \par\pause
$T_{\code{++}}(m + 1, n) = T_{\code{++}}(m, n) + O(1)$ \par\pause
$\implies$ \textcolor{blue}{$T_{\code{++}}(m, n) = O(m)$}
\end{exampleblock}

\end{frame}

\end{document}
